
---
output: 
  html_document:
    theme: null
    css: report.css
---





```{r echo = FALSE, message = FALSE, warning = FALSE}
# This section of text, defined by the ``` at its start and end, is
# called a chunk. It's basically a group of code that all works together
# to produce a plot or table (or a few plots and tables, if they're all
# related).
# This first chunk is always for setup. Note that I have "echo", "message",
# and "warning" all set to FALSE for this chunk. Loading packages and other
# setup tasks can produce of a lot messages and warnings that you don't want
# to show up in your report.
# You'll almost never want "echo" to be TRUE - that will show your R code
# in the report. But warnings can be helpful for finding bugs.


# Put this following line of code at the top of *every* script you write.
# Factors are R's data type for categorical and ordinal data. They are very
# useful, but R by default converts *all text data* to factors.
# You really don't want that.
options(stringsAsFactors = FALSE)


# Next, load up the packages you'll need.
# If you don't have these packages in your library, just run this code:
# install.packages(c("knitr", "plyr", "reshape2", "ggplot2", "scales", "xtable", "hflights"))



library(knitr)      # This is the package that generates the final report
library(plyr)       # Excellent tools for data manipulation and aggregation
library(reshape2)   # Lets you convert wide data to long and vice versa - more on that later
library(ggplot2)    # The best graphics package
library(scales)     # Some helper functions for ggplot
library(xtable)     # Helps print data.frames to HTML nicely



# Now that knitr is loaded, we can set some default chunk options.
opts_chunk$set(echo = FALSE,     # You'll never want your code in the report
               message = FALSE,  # Sometimes it's helfpul to turn messages on for debugging
               warning = FALSE,  # Also sometimes helpful
               dev = "png")      # This sets the format of your graphics - png is a good choice





# Now I'm going to create two functions: dfprint and dfprintif.
# You can print a data.frame directly to HTML, but it looks like hell.
# These functions combine a couple of different functions and some
# sensible defaults for printing tables to HTML.
# This is a function I put together, but hopefully someone smarter will put
# a better function into a package soon.
dfprint <- function(df, printdigits = 2) {

    print(
        xtable(format(df, 
                      na.encode = FALSE, 
                      digits = printdigits, 
                      nsmall = printdigits), 
               align = c("l", "l", rep("c", ncol(df) - 1))
        ),
        type = "html",
        include.rownames = FALSE,
        NA.string = "--")
}


# This is basically the same as dfprint(), except it lets you specify a 
# message if the data.frame has zero rows. This is especially useful for data
# QA reports, when you might have a table of erroneous records that (if all
# the records are cleaned up) will eventually be empty. Instead of just
# disappearing, dfprintif() lets you have a little message like
# "No errors found! Huzzah!"
dfprintif <- function(df, 
                      norowmsg = "No records to display.", 
                      printdigits = 2) {

    if(nrow(df) > 0) { dfprint(df, printdigits) } else {
        cat(norowmsg) }

}

```



```{r load_data}


# I've started a separate chunk to load in the data.
# It's helpful to use chunks to separate out related code (set up the report,
# load data, run the regression)
# and also to put slow code in its own chunk. You'll spend a lot of time
# re-running chunks to tweak the results, and you don't want to run any
# more code than you have to.

# Most of the time, you'll be reading data from these sources:
# - CSV files. Just type: read.csv("path/to/file.csv")
# - Excel files. Unless that file is being auto-generated by some process,
#   just export to CSV. Excel is a nightmare.
# - A database. The package "RODBC" is essential for working with databases.

# For this example, I'm going to use a dataset of flights that left Houston
# in 2011.
library(hflights)


```


```{r clean_data, results = 'hide'}


# I don't want any of this stuff showing up in the final report, so I've set
# results = 'hide' in the chunk header.



# Cleaning data is probably about 80% of the work in any analysis.
# You should always be suspicious of your data quality.
# There are a few major things you'll need to check in every dataset:
# 1. Missing data. Where in the data are values missing? Are they acceptable?
#    How are you going to account for those values in your analysis?
# 2. Data type. R stores variables as numeric vectors, character vectors,
#    factors, dates, date-times (aka POSIXct), and logical (TRUE, FALSE, NA). 
#    To start with, you'll want all of your variables to be as close to their
#    "true" data type as possible.
#    Later on, you can tweak them a bit for specific purposes.
# 3. Out-of-bound values. Do you have dates from the 1800s or the 2300s? 
#    Is someone in your data 108 inches tall? Plotting and tables are best ways
#    to make surethat your values fall into the realm of plausibility.
# 4. Plausible combinations. If a survey respondent is giving contradictory
#    answers, there might be a problem with your response coding. 

# Here are some examples of those checks on this flights data.



# Missing data
# Here's a quick way to check for missing values in the entire dataset:
apply(hflights, MARGIN = 2, FUN = function(x) { sum(is.na(x)) } )
# apply() performs the FUNction you give it to each row (MARGIN = 1) or
# column (MARGIN = 2) of a dataset. Here, I'm asking apply to give me the
# count of NA values in each column - that is, the sum() of the is.na() values.
# Caveat: Missing values get coded in many different ways! Keep your eyes out
# for "", 99, -, ., and so on.

# Let's check some of those missing values. I'm going to subset to all of the
# records where DepTime is NA. Since there are 2905 of those records,
# I'm going to use head() to get just the first 10 records.
head(subset(hflights, is.na(DepTime)))

# Looks like they were all cancelled (Cancelled = 1). Let's check.
table(subset(hflights, is.na(DepTime))$Cancelled, exclude = NULL)
# Here, I'm making a table() of the Cancelled variable for all of the
# records with DepTime = NA. All 2905 of them were cancelled.
# Whenever you're using table, always specify "exclude = NULL" - otherwise,
# table() will hide NA values from you, which you almost always want to know about.





# Data type
# The quickest way to check data types is with str(). If you've named your
# variables well and know your data, this might be all you need to do.
str(hflights)

# These are looking good, although in my mind "Cancelled" and "Diverted"
# should be a logical variable (aka a Boolean). Not a big deal, though.
# My departure and arrival times are split across several variables, though,
# and that's a pain to work with. Here's how to convert those variables to
# a single date object.
hflights$DepDate <- with(hflights,
    as.Date(paste(Year,
                  Month,
                  DayofMonth,
                  sep = "-"),
            format = "%Y-%m-%d"
    )
)
# with() is a function that tells R that I'm working within the hflights 
# data.frame, so I can skip writing "hflights$" in front of every variable
# I mention.
# as.Date() can be used to convert any character-format date into a true
# true Date-class variable. To get that character-format date, I'm going to
# paste() together all of the date variables and separate them with a dash
# so they look like "2011-12-04". I then tell as.Date() that the year is
# first (%Y) followed by a dash, then the month (%m), then a dash, then the
# day (%d).

# The same thing works for creating date-times, except I'll use as.POSIXct()
# instead of as.Date() (POSIX is a set of international standards for stuff 
# like ethis). This looks just about the same, except this time I'm including
# the hours and minutes.
hflights$DepDateTime <- with(hflights,
    as.POSIXct(paste(DepDate, # Hey, I made it, might as well use it...
                     DepTime,
                     sep = " "),
               format = "%Y-%m-%d %k%M"
    )
)

# Whenever you're converting variable types, there are two ESSENTIAL rules:
# 1. Never overwrite the original variable. Always make a new one.
# 2. Always check to be sure the conversion went as you expected.
# So - let's check.
hflights[c("Year", "Month", "DayofMonth", "DepTime", "DepDate", "DepDateTime")]

# It's pretty obvious that not all of the DepDateTimes worked - specifically,
# none of the AM flights were successful. That's probably because they don't
# have that leading zero.
# There's probably a magic specification for 24-hour hours without leading
# zeroes, but I can't remember it - so I'll check the docs.
?strptime # All of the date-time format codes are hiding in here
# I can see %H as hours (00-23) - but I've got (0-23) hours.
# I tried %k too (single digits preceded by a blank), but no luck.
# Time for some help: http://stackoverflow.com/questions/5812493/adding-leading-zeros-using-r
sprintf("%04s", hflights$DepTime) # No idea how this works, but it looks good

hflights$DepDateTime <- with(hflights,
    as.POSIXct(paste(DepDate, # Hey, I made it, might as well use it...
                     sprintf("%04s", DepTime),
                     sep = " "),
               format = "%Y-%m-%d %k%M"
    )
)

# One last check
hflights[c("Year", "Month", "DayofMonth", "DepTime", "DepDate", "DepDateTime")]

```



```{r oob, results = 'hide', fig.show = 'hide'}

# Now let's checkk for out-of-bounds values.
# I don't want this plot to show up in my final report, so I've set
# this chunk to fig.show = 'hide'

# Since we just made that departure date time, let's check it.
# Remember, this dataset is flights from just 2011.

# A quick way to check any quantitative variable:
summary(hflights$DepDateTime)


# Plotting is always a good idea, too. I use ggplot almost exclusively.
# It takes a little more time to learn the basics, but it's much easier
# to produce high-quality plots than with the base graphics package.
ggplot(hflights, aes(x = DepDateTime)) +
    geom_histogram() +
    theme_bw()

# It kinda looks like some flights happened before January 1, but
# summary() assures me that it didn't.


# How about flight times?
summary(hflights$ActualElapsedTime)

# Um... is 575 minutes a plausible flight time? Sounds dreadful. I can get that
# in hours easily by dividng that entire summary by 60.
summary(hflights$ActualElapsedTime) / 60 # 9.6 hours. Ugh.




```



```{r plausible_combos, results = 'hide', fig.show = 'hide'}


# Finally, we need to check for plausible combinations of values.
# Presumably, a flight can't be both cancelled and diverted.
with(hflights, table(Cancelled, Diverted, exclude = NULL))

# Another way to get the same table in so-called "long" format is to use
# the count() function from plyr. I find this a bit easier to read.
count(hflights, c("Cancelled", "Diverted"))

# Let's just do a quick check to make sure everybody shows up in those tables
nrow(hflights)
sum(with(hflights, table(Cancelled, Diverted, exclude = NULL)))
sum(count(hflights, c("Cancelled", "Diverted"))$freq)



# Do flight times at least roughly correspond to distance traveled? Plot it.
# Because there are so many points, I'm going to make them transparent
# (alpha = 0.2). I'm going to slap a smoothed trend line on there, too.
ggplot(hflights, aes(x = Distance, y = ActualElapsedTime)) +
    geom_point(alpha = 0.2) +
    geom_smooth() +
    expand_limits(y = 0) +
    theme_bw()

# What's with that crazy gap between 2000 and 3000? Well, here's the 2000 mile
# radius around Houston: http://maps.google.com/maps/api/staticmap?size=600x500&path=fillcolor:0x00FF00|weight:1|color:0xFFFFFF|enc:axaeJv~_eQdwLiwdMneh@spbMhmcAmc~Lpj~AspwLxxxBaynLbtrCe~cLlxkDwawKxadEsehKll{EglwJttqFexdJdwfGglpIlpzGykzHr}lHezbHr{}Ha{iG|gmIiroFb`{I_dtEbbgJqtwD|kqJghzC|{yJyc|B~p`Kwk}AzieKce~@zehKot^pdiK?|ehKnt^xieKbe~@~p`Kvk}A|{yJxc|B|kqJfhzCbbgJptwDb`{I~ctE|gmIhroFr{}H`{iGr}lHdzbHlpzGxkzHdwfGflpIttqFdxdJll{EflwJxadErehKlxkDvawKbtrCd~cLxxxB`ynLpj~ArpwLhmcAlc~Lneh@rpbMdwLhwdMewLhwdMoeh@rpbMimcAlc~Lqj~ArpwLyxxB`ynLctrCd~cLmxkDvawKyadErehKml{EflwJutqFdxdJewfGflpImpzGxkzHs}lHdzbHs{}H`{iG}gmIhroFc`{I~ctEcbgJptwD}kqJfhzC}{yJxc|B_q`Kvk}AyieKbe~@}ehKnt^qdiK?{ehKot^{ieKce~@_q`Kwk}A}{yJyc|B}kqJghzCcbgJqtwDc`{I_dtE}gmIiroFs{}Ha{iGs}lHezbHmpzGykzHewfGglpIutqFexdJml{EglwJyadEsehKmxkDwawKctrCe~cLyxxBaynLqj~AspwLimcAmc~Loeh@spbMewLiwdM&sensor=true


```






```{r markdown intro}

# Below, you'll see some text outside of a chunk for the first time.
# This text is called Markdown - it's basically a shorthand way of writing
# HTML. The key aspects of Markdown that you 'll need to know are:
# Headers: For a top-level header, just put a pound sign # in front of the header text.
#          Section headers are two pound signs ##, and subheaders are three ###
# Lists (Unordered): Put a space-dash-space in front of each item in the list ( - ).
# Lists (Numbered): Put a number, a period, and a space in front of each
#                   item (1. ). knitr will figure out the count for you, so you 
#                   can actually use 1. for every item in the list.

```




# Outbound Flights From Houston, TX - 2011

Report updated at `r paste(Sys.time())`



## Number of Flights by Airline

```{r flights_by_airline}

# Here's an example of a barplot using ggplot. ggplot understands that when I
# ask for a barplot, I want the counts - so I don't have to aggregate anything
# in advance.
ggplot(hflights, aes(x = UniqueCarrier)) +
    geom_bar() +
    labs(x = "Carrier",
         y = "Number of Flights") +
    theme_bw()



```



## Flights by Day

```{r flights_by_date, fig.show = 'hide'}

# I'm curious about how many flight depart each day. One way to examine that
# is to just look at the total flights each day:
ggplot(hflights, aes(x = weekdays(DepDate))) +
    geom_bar() +
    labs(x = "Day of Week",
         y = "Total Flights in 2011") +
    theme_bw()


```



```{r flights_by_date2}


# That's nice, by why is my x-axis in alphabetical order? If I made the plot
# with the raw DayOfWeek number, the order would be correct - but I like the days.
# This calls for a factor.
hflights$DayOfWeek_f <- factor(x = weekdays(hflights$DepDate),
                               levels = c("Monday", "Tuesday", "Wednesday",
                                          "Thursday", "Friday", "Saturday",
                                          "Sunday"))


# Because DayOfWeek_f is a factor, ggplot will plot the bars in order.
ggplot(hflights, aes(x = DayOfWeek_f)) +
    geom_bar() +
    labs(x = "Day of Week",
         y = "Total Flights in 2011") +
    theme_bw()



# The variability might be interesting, too. For that, I need to do a little
# aggregation. I'm going to use ddply() from the plyr package - although there
# are simpler approaches, ddply() is one of my favorite tools.
# It works by splitting the data up based on one or more variables,
# applying the same functions to each subset, and then recombining the
# results into a data.frame.
# I'm going to calculate a little more than I need for just this plot.

flights_by_date <- ddply(hflights, # The data to split
                         .var = c("DepDate", "DayOfWeek_f"),
                         .fun = summarise, # I'll apply summarise to each subset
                         
    # After you specify .fun, you can pass other arguments to that function - 
    # for example, if your .fun was sum, you might want to pass "na.rm = TRUE"
    # to exclude missing values.
    # For summarise(), each argument you pass will be turned into a new variable
    # in a summary data frame. Hard to explain - just try it.
    n_flights = length(FlightNum),            # How many flights
    n_planes = length(unique(TailNum)),       # How many unique planes,
    n_cancelled = sum(Cancelled),             # How many were cancelled
    per_cancelled = n_cancelled / n_flights,  # % cancelled - using vars I just made
    n_diverted = sum(Diverted),               # Number diverted
    per_diverted = n_diverted / n_flights     # % diverted

)

        
        
# Now that I have the number of flights for each day, I can check out
# the variability.
ggplot(flights_by_date, aes(x = DayOfWeek_f, y = n_flights)) +
    geom_boxplot() +
    labs(x = "Day of Week",
         y = "Number of Flights") +
    theme_bw()


# It looks like Houston can handle ~700 flights per day at most. Saturdays
# are usually well below that, though, average ~520.


```

## Cancellations By Day

```{r cancelled_by_day}

# Maybe flight cancellations are somehow related to the day of the week.
# ggplot can handle the aggregation, but I'd like something nicer-looking than
# the ones and zeroes of the Cancelled field.
# This is very common; lots of datasets map binary values to ones and zeroes.
# That isn't really necessary in R, and it makes plotting and other output
# look amateurish. Let's make a factor out of it.
hflights$Cancelled_f <- factor(hflights$Cancelled,
                               levels = c(0, 1), # Levels means the actual values
                               labels = c("Successful", "Cancelled")
)


# I'm going to spruce this one up a little bit with black outlines for the
# bars (color = "black") and nicer fill colors (scale_fill_brewer(...)).
# The color options using scale_fill_ and scale_color_ are basically limitless.
# The "brewer" here refers to colorbrewer2.org - which is an incredible website
# for choosing colors for graphics.
ggplot(hflights, aes(x = DayOfWeek_f, fill = Cancelled_f)) +
    geom_bar(color = "black") +
    labs(x = "Day of Week",
         y = "Number of Flights",
         fill = "Cancelled") +
    scale_fill_brewer(palette = "Paired") +
    theme_bw()


````



```{r bar_position, fig.show = 'hide'}


# Notice how x automatically determines which bars are laid out side-by-side
# and fill determines which bars are stacked. You can tweak those arrangements
# by adjusting the position argument in geom_bar - try this, for example:
ggplot(hflights, aes(x = DayOfWeek_f, fill = Cancelled_f)) +
    geom_bar(position = "dodge", color = "black") +
    labs(x = "Day of Week",
         y = "Number of Flights",
         fill = "Cancelled") +
    scale_fill_brewer(palette = "Paired") +
    theme_bw()


# You can also pass position = "fill" to get 100% stacked bars.
# When you're plotting percenetages, it's often easier to work with
# the proportion (proportion = x / n, percentage = x / n * 100)
# and then have ggplot relabel the axis appropriately using
# scale_y_continuous(label = percent) - see below.
ggplot(hflights, aes(x = DayOfWeek_f, fill = Cancelled_f)) +
    geom_bar(position = "fill", color = "black") +
    labs(x = "Day of Week",
         y = "Number of Flights",
         fill = "Cancelled") +
    scale_y_continuous(label = percent) +
    scale_fill_brewer(palette = "Paired") +
    theme_bw()

```


```{r bar_and_text}

# In this case, though, the small fraction of cancelled flights makes it
# tough to see any variation. A couple of ways to address that are to
# add text to the graph and to plot just the percentages cancelled.
# It's probably easiest to aggregate the data before trying to plot those.
cancel_summary <- ddply(hflights,
                        .var = "DayOfWeek_f",
                        .fun = summarise,
                        
    n_flights = length(Cancelled),
    n_cancelled = sum(Cancelled),
    prop_cancelled = n_cancelled / n_flights,
    per_cancelled_label = paste0(formatC(prop_cancelled * 100,
                                         digits = 1,
                                         format = "f"),
                                 "%")
    
)


# Instead of plotting hflights directly, I'm going to plot its summary.
# Notice how geom_bar and geom_text have different names for their y value
# arguments; bar wants "weight" - it normally just counts the objects in the
# data with a particular value, but because we've aggregated those values,
# we have to weight them.
# Conversely, text takes a y value - but I subtract a small amount from it
# so that the text will print just below the tops of the bars (and make
# them white so that they'll be visible).
# Finally, I use scale_y_continuous to convert the raw proportions of
# prop_cancelled into nice-looking percentages. Try deleting that line
# to see how it changes the plot.
ggplot(cancel_summary, aes(x = DayOfWeek_f)) +
    geom_bar(aes(weight = prop_cancelled), 
             fill = "#1f78b4") +
    geom_text(aes(y = prop_cancelled - 0.001, label = per_cancelled_label),
              color = "white") +
    scale_y_continuous(label = percent) +
    labs(x = "Day of Week", y = "Percent of Flights Cancelled") +
    theme_bw()


# NOW there's a very distinct pattern!


```




## Top Destinations



```{r top_destinations, fig.show = 'hide'}

# Now I'd like to look at the top destinations. The plotting is familiar by
# now:
ggplot(hflights, aes(x = Dest)) +
    geom_bar() +
    labs(x = "Destination",
         y = "Number of Flights") +
    theme_bw()
    

# Except there are way too many. In this case, the best thing to do is
# aggregate the results outside of ggplot and subset to the top destinations.
# I'll use count() again for this, but I'm going to wrap it in yet another
# plyr function to get just the top destinations.
# You can often save yourself some typing by wrapping functions inside of
# other functions like this, but remember that your top priority should
# always be having code that's easy to read. When you see some code you've
# written after a few months, you'll have no idea what you were thinking.
# So it's important to write readable, commented code.
top_destinations <- arrange(count(hflights, "Dest"), desc(freq))


# There's a natural order here, just as with days of the week - highest to lowest.
# That's a situation that calls for a factor.
top_destinations$Dest_f <- factor(top_destinations$Dest,
                                  levels = top_destinations$Dest)


```



```{r plot_top_destinations}

# Try plotting just the top ten results. I'm just going to use bracket indexing
# to get the top ten rows, since I know they're sorted correctly.
# Since the data is pre-aggregated, I need to tell R that the bars should
# be proportional to frequency with weight = freq.
ggplot(top_destinations[1:10, ], aes(x = Dest_f, weight = freq)) +
    geom_bar() +
    labs(x = "Destination",
         y = "Number of Flights") +
    theme_bw()


# They're mostly flying between Houston and Dallas. Maniacs.


```


```{r print_top_destinations, results = 'asis'}


# Since we've already got the top destinations in a table format, it's a good
# opportunity to print it. We can't just dump it to HTML, unfortunately - it
# needs to get parsed from plain text. The function dfprintif(), created way
# back in the first chunk, is what I use to do this.
# Since that function returns raw HTML, I need to set this chunk to have
# results = 'asis' - knitr doesn't need to convert this output to Markdown
# because it's already HTML.


# I'm going to give the table pretty names.
# Normally you wouldn't give R variables names like this because they'd
# be a pain to type out, but they're nicer for a finished report.

names(top_destinations) <- c("Dest", "Number of Flights", "Destination")


# I'm just going to print the top ten rows and one destination variable
dfprintif(top_destinations[1:10, c("Destination", "Number of Flights")])






```


## Your Turn

```{r your_turn, results = 'hide'}

# What other variables might be of interest to travelers, air traffic controllers,
# flight crews? Look through the data to come up with some ideas, and then
# explore them with some plots and tables.

head(hflights)


```











